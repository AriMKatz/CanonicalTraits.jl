<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CanonicalTraits.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CanonicalTraits.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li><a class="toctext" href="#Trait-Definition-1">Trait Definition</a></li><li><a class="toctext" href="#Implementation-1">Implementation</a></li><li><a class="toctext" href="#Functional-Dependency-1">Functional Dependency</a></li><li><a class="toctext" href="#Use-Case-from-An-Example:-Gram-Schmidt-Orthogonalization-1">Use Case from An Example: Gram-Schmidt Orthogonalization</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/thautwarm/CanonicalTraits.jl/blob/master/docs/src/index.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="CanonicalTraits.jl-1" href="#CanonicalTraits.jl-1">CanonicalTraits.jl</a></h1><ul></ul><h2><a class="nav-anchor" id="Trait-Definition-1" href="#Trait-Definition-1">Trait Definition</a></h2><pre><code class="language-julia">@trait Addable{L, R} begin
    (+) :: [L, R] =&gt; Any
    (+) = Base.:+
end</code></pre><p>Above code gives a naive implementation of <code>+</code>.</p><p><code>(+) :: [L, R] =&gt; Any</code> says <code>(+)</code> is a function that takes 2 arguments typed <code>L</code> and <code>R</code>, and return an <code>Any</code>.</p><p><code>(+) = Base.:+</code> says <code>+</code> has a default implementation <code>Base.:+</code>.</p><h2><a class="nav-anchor" id="Implementation-1" href="#Implementation-1">Implementation</a></h2><p>If all methods have a default implementation, you can do</p><pre><code class="language-julia">@implement Addable{Int, Int}</code></pre><p>Otherwise, if there&#39;s such a trait</p><pre><code class="language-julia">@trait Show{A} begin
   show :: A =&gt; String
end</code></pre><p>We&#39;ll have</p><pre><code class="language-julia-repl">julia&gt; @implement Show{Int}
ERROR: LoadError: No default method show for Show.

julia&gt; @implement Show{Int} begin
    show(x) = string(x)
end

julia&gt; show(114514)
&quot;114514&quot;</code></pre><h2><a class="nav-anchor" id="Functional-Dependency-1" href="#Functional-Dependency-1">Functional Dependency</a></h2><p>This is an example of defining Vector-like traits,</p><pre><code class="language-julia">function vect_eltype_infer end
@trait Vect{F, V} where {F = vect_infer_helper(V)} begin
    scalar_mul :: [F, V] =&gt; V
    scalar_div :: [V, F] =&gt; V

    vec_add    :: [V, V] =&gt; V
    vec_sub    :: [V, V] =&gt; V

    scalar_add :: [F, V] =&gt; V
    scalar_sub :: [V, F] =&gt; V

    scalar_div(vec :: V, scalar :: F) = scalar_mul(one(F)/scalar, vec)
    scalar_sub(vec :: V, scalar :: F) = scalar_add(-scalar, vec)
    vec_sub(vec1 :: V, vec2 :: V)     = vec_add(vec1, scalar_mul(-one(F), vec2))
end</code></pre><p>Note that, for some methods of <code>Vect</code>, we cannot infer out the type <code>F</code> with their argument types:</p><pre><code class="language-julia">vec_add    :: [V, V] =&gt; V
vec_sub    :: [V, V] =&gt; V</code></pre><p>However, for instance, we know,</p><ul><li>when <code>V</code>  is <code>Vector{T}</code>, <code>V</code> is <code>T</code>.</li><li>when <code>V</code> is <code>NTuple{5, T}</code>, <code>V</code> is <code>T</code></li><li>etc.</li></ul><p>This is called functional dependency, and to work with this, we provide the capability of using this, check the head of the definition of <code>Vect</code>:</p><pre><code class="language-julia">@trait Vect{F, V} where {F = vect_infer_helper(V)} begin</code></pre><p>Which means that <code>F</code> is decided by <code>V</code> with <code>vect_infer_helper</code>.</p><p>This is an example of making <code>Tuple{F, F}</code> Vector-like:</p><pre><code class="language-julia">vect_infer_helper(::Type{Tuple{F, F}}) where F&lt;:Number = F

@implement Vect{F, Tuple{F, F}} where F &lt;: Number begin
    scalar_add(num, vec) =
        (vec[1] + num, vec[2] + num)
    vec_add(vec1, vec2) =
        (vec1[1] + vec2[1], vec1[2] + vec2[2])
    scalar_mul(num, vec) =
        (num * vec[1], num * vec[2])
end</code></pre><h2><a class="nav-anchor" id="Use-Case-from-An-Example:-Gram-Schmidt-Orthogonalization-1" href="#Use-Case-from-An-Example:-Gram-Schmidt-Orthogonalization-1">Use Case from An Example: Gram-Schmidt Orthogonalization</a></h2><p>Traits manage constraints, making the constraints reasonable and decoupling implementations.</p><p>In the late 2019, a friend of mine, Yinbo, asked me if traits can help writing orthogonalizations, because he is working for projects about JuliaDiffEq.</p><p>After pondering for some time, I made a trait-based design for Gram-Schmidt orthogonalization.</p><p>I tidied up the logic in this way:</p><ol><li><code>Gram-Schmidt orthogonalization</code> is defined in an <strong>inner product space</strong>.</li><li>An inner product space derives a trait, I call it <code>InnerProduct</code>.</li><li>An inner prduct space is a vector space, with an additional structure called an inner product, which tells that we need a <strong>vector space</strong>.</li><li>A vector space, a.k.a linear space, given a set of scalar numbers <code>F</code>, it is a carrier set <code>V</code> occupied with these operations:<ul><li>vector addition: <code>+ : V × V → V</code></li><li>scalar multiplication: <code>* : F × V → V</code></li></ul></li></ol><pre><code class="language-none">Just make a trait `Vect` for the vector space.</code></pre><p>Then we can use <code>CanonicalTraits.jl</code> to transform above mathematical hierarchy into elegant Julia codes:</p><pre><code class="language-julia">function scalartype_of_vectorspace end
@trait Vect{F &lt;: Number, V} where
    {F = scalartype_of_vectorspace(V)} begin
   vec_add    :: [V, V] =&gt; V
   scalar_mul :: [F, V] =&gt; V
end

@trait InnerProduct{F &lt;: Number, V} where 
    {F = scalartype_of_vectorspace(V)} begin
    dot :: [V, V] =&gt; F
end</code></pre><p>Then we can implement Gram-Schmidt orthogonalization,</p><pre><code class="language-julia">function gram_schmidt!(v :: V, vs :: Vector{V})::V where V
    for other in vs
        coef = dot(v, other) / dot(other, other)
        incr = scalar_mul(-coef, other)
        v = vec_add(v, incr)
    end
    magnitude = sqrt(dot(v, v))
    scalar_mul(1/magnitude, v)
end</code></pre><p><code>gram_schmidt!(a, [b, c, d])</code> will Gram-Schmidt orthogonalize <code>a</code> with <code>b, c, d</code>.</p><p>Now, other than a clean implementation, another advantage of using traits comes out:</p><pre><code class="language-julia">julia&gt; gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])
ERROR: MethodError: no method matching scalartype_of_vectorspace(::Type{Array{Float64,1}})</code></pre><p>Okay, we want to use <code>gram_schmidt!</code> on <code>Vector{Float64}</code>, but we have to implement <code>scalartype_of_vectorspace</code> first.</p><p>So we just say the scalar set is the real numbers&quot;</p><pre><code class="language-julia">julia&gt; scalartype_of_vectorspace(::Type{Vector{Float64}}) = Real

julia&gt; gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])
ERROR: Not implemented trait InnerProduct for (Real, Array{Float64,1}).</code></pre><p>Okay, we should implement <code>InnerProduct{Real, Vector{Float64}}</code>.</p><pre><code class="language-julia">julia&gt; @implement InnerProduct{Real, Vector{Float64}} begin
           dot(a, b) = sum([ai*bi  for (ai, bi) in zip(a, b)])
       end

julia&gt; gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])
ERROR: Not implemented trait Vect for (Float64, Array{Float64,1}).</code></pre><p>Okay, we implement <code>Vect{Real, Vector{Float64}}</code>.</p><pre><code class="language-julia">julia&gt; @implement Vect{Real, Vector{Float64}} begin
          vec_add(x, y) = Float64[xi + yi for (xi, yi) in zip(x, y)]
          scalar_mul(a, x) = Float64[(a)xi for xi in x]
       end
julia&gt; gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])
3-element Array{Float64,1}:
 0.0
 0.0
 1.0</code></pre><p>Nice.</p><p>Besides, note that <code>CanonicalTraits.jl</code> is zero-cost.</p><footer><hr/></footer></article></body></html>
