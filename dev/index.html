<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CanonicalTraits.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CanonicalTraits.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li><a class="toctext" href="#Features-1">Features</a></li><li><a class="toctext" href="#Trait-Definition-1">Trait Definition</a></li><li><a class="toctext" href="#Implementation-1">Implementation</a></li><li><a class="toctext" href="#Functional-Dependency-1">Functional Dependency</a></li><li><a class="toctext" href="#Flexible-Instances-and-Flexible-Classes-1">Flexible Instances &amp; Flexible Classes</a></li><li><a class="toctext" href="#Use-Case-from-An-Example:-Gram-Schmidt-Orthogonalization-1">Use Case from An Example: Gram-Schmidt Orthogonalization</a></li><li><a class="toctext" href="#Use-Case:-Modeling-Algebraic-Structures-1">Use Case: Modeling Algebraic Structures</a></li><li><a class="toctext" href="#Zero-Cost-1">Zero Cost</a></li><li><a class="toctext" href="#Limitations-1">Limitations</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/thautwarm/CanonicalTraits.jl/blob/master/docs/src/index.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="CanonicalTraits.jl-1" href="#CanonicalTraits.jl-1">CanonicalTraits.jl</a></h1><ul></ul><h2><a class="nav-anchor" id="Features-1" href="#Features-1">Features</a></h2><ol><li><a href="#Zero-cost">Zero-cost</a> abstractions(via <code>@implement!</code>)</li><li>Multiple-param traits</li><li>Functional dependencies</li><li>Implemented via dictionay passing algorithm</li><li>Elegant notations</li><li>Flexible Instances &amp; Flexible Classes</li></ol><h2><a class="nav-anchor" id="Trait-Definition-1" href="#Trait-Definition-1">Trait Definition</a></h2><pre><code class="language-julia">@trait Addable{L, R} begin
    (+) :: [L, R] =&gt; Any
    (+) = Base.:+
end</code></pre><p>Above code gives a naive implementation of <code>+</code>.</p><p><code>(+) :: [L, R] =&gt; Any</code> says <code>(+)</code> is a function that takes 2 arguments typed <code>L</code> and <code>R</code>, and return an <code>Any</code>.</p><p><code>(+) = Base.:+</code> says <code>+</code> has a default implementation <code>Base.:+</code>.</p><p>Note, the form <code>@trait A{B, C, D &lt;: Number, E &lt;: AbstractString}</code> is supported as well.</p><h2><a class="nav-anchor" id="Implementation-1" href="#Implementation-1">Implementation</a></h2><p>If all methods have a default implementation, you can do</p><pre><code class="language-julia">@implement Addable{Int, Int}</code></pre><p>Otherwise, if there&#39;s such a trait</p><pre><code class="language-julia">@trait Show{A} begin
   show :: A =&gt; String
end</code></pre><p>We&#39;ll have</p><pre><code class="language-julia-repl">julia&gt; @implement Show{Int}
ERROR: LoadError: No default method show for Show.

julia&gt; @implement Show{Int} begin
    show(x) = string(x)
end

julia&gt; show(114514)
&quot;114514&quot;</code></pre><h2><a class="nav-anchor" id="Functional-Dependency-1" href="#Functional-Dependency-1">Functional Dependency</a></h2><p>This is an example of defining Vector-like traits,</p><pre><code class="language-julia">function vect_eltype_infer end
@trait Vect{F, V} where {F = vect_infer_helper(V)} begin
    scalar_mul :: [F, V] =&gt; V
    scalar_div :: [V, F] =&gt; V

    vec_add    :: [V, V] =&gt; V
    vec_sub    :: [V, V] =&gt; V

    scalar_add :: [F, V] =&gt; V
    scalar_sub :: [V, F] =&gt; V

    scalar_div(vec :: V, scalar :: F) = scalar_mul(one(F)/scalar, vec)
    scalar_sub(vec :: V, scalar :: F) = scalar_add(-scalar, vec)
    vec_sub(vec1 :: V, vec2 :: V)     = vec_add(vec1, scalar_mul(-one(F), vec2))
end</code></pre><p>Note that, for some methods of <code>Vect</code>, we cannot infer out the type <code>F</code> with their argument types:</p><pre><code class="language-julia">vec_add    :: [V, V] =&gt; V
vec_sub    :: [V, V] =&gt; V</code></pre><p>However, for instance, we know,</p><ul><li>when <code>V</code>  is <code>Vector{T}</code>, <code>V</code> is <code>T</code>.</li><li>when <code>V</code> is <code>NTuple{5, T}</code>, <code>V</code> is <code>T</code></li><li>etc.</li></ul><p>This is called functional dependency, and to work with this, we provide the capability of using this, check the head of the definition of <code>Vect</code>:</p><pre><code class="language-julia">@trait Vect{F, V} where {F = vect_infer_helper(V)} begin</code></pre><p>Which means that <code>F</code> is decided by <code>V</code> with <code>vect_infer_helper</code>.</p><p>This is an example of making <code>Tuple{F, F}</code> Vector-like:</p><pre><code class="language-julia">vect_infer_helper(::Type{Tuple{F, F}}) where F&lt;:Number = F

@implement Vect{F, Tuple{F, F}} where F &lt;: Number begin
    scalar_add(num, vec) =
        (vec[1] + num, vec[2] + num)
    vec_add(vec1, vec2) =
        (vec1[1] + vec2[1], vec1[2] + vec2[2])
    scalar_mul(num, vec) =
        (num * vec[1], num * vec[2])
end</code></pre><h2><a class="nav-anchor" id="Flexible-Instances-and-Flexible-Classes-1" href="#Flexible-Instances-and-Flexible-Classes-1">Flexible Instances &amp; Flexible Classes</a></h2><pre><code class="language-julia">@trait Add1{T &lt;: Number} begin
    add1 :: [T] =&gt; T
end
@trait Add1{T} &gt;: Addn{T &lt;: Number} begin
    addn :: [Int, T] =&gt; T
    addn(n, x) = let s = x; for i in 1:n; s = add1(s) end; s; end
end

@implement Add1{Int} begin
    add1(x) = x + 1
end
@implement Addn{Int}
@implement! Add1{T} &gt;: Add1{Vector{T}} where T begin
    add1(xs) = add1.(xs)
end</code></pre><p>Then we can use them this way:</p><pre><code class="language-julia-repl">julia&gt; add1([1])
1-element Array{Int64,1}:
 2

julia&gt; add1(1)
2

julia&gt; addn(5, 1)
6

julia&gt; addn(5, 1.2)
ERROR: Not implemented trait Add1 for (Float64).

julia&gt; add1([1.2])
ERROR: Not implemented trait Add1 for (Float64).</code></pre><h2><a class="nav-anchor" id="Use-Case-from-An-Example:-Gram-Schmidt-Orthogonalization-1" href="#Use-Case-from-An-Example:-Gram-Schmidt-Orthogonalization-1">Use Case from An Example: Gram-Schmidt Orthogonalization</a></h2><p>Traits manage constraints, making the constraints reasonable and decoupling implementations.</p><p>In the late 2019, a friend of mine, Yinbo, asked me if traits can help writing orthogonalizations, because he is working for projects about JuliaDiffEq.</p><p>After pondering for some time, I made a trait-based design for Gram-Schmidt orthogonalization.</p><p>I tidied up the logic in this way:</p><ol><li><code>Gram-Schmidt orthogonalization</code> is defined in an <strong>inner product space</strong>.</li><li>An inner product space derives a trait, I call it <code>InnerProduct</code>.</li><li>An inner prduct space is a vector space, with an additional structure called an inner product, which tells that we need a <strong>vector space</strong>.</li><li>A vector space, a.k.a linear space, given a set of scalar numbers <code>F</code>, it is a carrier set <code>V</code> occupied with following operations, and we make a trait <code>Vect</code> for the vector space:<ul><li>vector addition: <code>+ : V × V → V</code></li><li>scalar multiplication: <code>* : F × V → V</code>  </li></ul></li></ol><p>Now, we could use <code>CanonicalTraits.jl</code> to transform above mathematical hierarchy into elegant Julia codes:</p><pre><code class="language-julia">function scalartype_of_vectorspace end
@trait Vect{F &lt;: Number, V} where
    {F = scalartype_of_vectorspace(V)} begin
   vec_add    :: [V, V] =&gt; V
   scalar_mul :: [F, V] =&gt; V
end

@trait InnerProduct{F &lt;: Number, V} where 
    {F = scalartype_of_vectorspace(V)} begin
    dot :: [V, V] =&gt; F
end</code></pre><p>Then we can implement Gram-Schmidt orthogonalization,</p><pre><code class="language-julia">function gram_schmidt!(v :: V, vs :: Vector{V})::V where V
    for other in vs
        coef = dot(v, other) / dot(other, other)
        incr = scalar_mul(-coef, other)
        v = vec_add(v, incr)
    end
    magnitude = sqrt(dot(v, v))
    scalar_mul(1/magnitude, v)
end</code></pre><p><code>gram_schmidt!(a, [b, c, d])</code> will Gram-Schmidt orthogonalize <code>a</code> with <code>b, c, d</code>.</p><p>Now, other than a clean implementation, another advantage of using traits comes out:</p><pre><code class="language-julia">julia&gt; gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])
ERROR: MethodError: no method matching scalartype_of_vectorspace(::Type{Array{Float64,1}})</code></pre><p>Okay, we want to use <code>gram_schmidt!</code> on <code>Vector{Float64}</code>, but we have to implement <code>scalartype_of_vectorspace</code> first.</p><p>So we just say the scalar set is the real numbers&quot;</p><pre><code class="language-julia">julia&gt; scalartype_of_vectorspace(::Type{Vector{Float64}}) = Real

julia&gt; gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])
ERROR: Not implemented trait InnerProduct for (Real, Array{Float64,1}).</code></pre><p>Okay, we should implement <code>InnerProduct{Real, Vector{Float64}}</code>.</p><pre><code class="language-julia">julia&gt; @implement InnerProduct{Real, Vector{Float64}} begin
           dot(a, b) = sum([ai*bi  for (ai, bi) in zip(a, b)])
       end

julia&gt; gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])
ERROR: Not implemented trait Vect for (Float64, Array{Float64,1}).</code></pre><p>Okay, we implement <code>Vect{Real, Vector{Float64}}</code>.</p><pre><code class="language-julia">julia&gt; @implement Vect{Real, Vector{Float64}} begin
          vec_add(x, y) = Float64[xi + yi for (xi, yi) in zip(x, y)]
          scalar_mul(a, x) = Float64[(a)xi for xi in x]
       end
julia&gt; gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])
3-element Array{Float64,1}:
 0.0
 0.0
 1.0</code></pre><p>Nice.</p><p>Besides, note that <code>CanonicalTraits.jl</code> is zero-cost.</p><h2><a class="nav-anchor" id="Use-Case:-Modeling-Algebraic-Structures-1" href="#Use-Case:-Modeling-Algebraic-Structures-1">Use Case: Modeling Algebraic Structures</a></h2><pre><code class="language-julia">julia&gt; @trait Monoid{A} begin
                  mempty :: Type{A} =&gt; A
                  # a method with two arguments
                  (⊕)    :: [A, A] =&gt; A
              end


julia&gt; @implement Monoid{Num} where Num &lt;: Number begin
           mempty(::Type{Num}) = zero(Num)
           (a :: Num) ⊕ (b :: Num) = a + b
       end

julia&gt; using BenchmarkTools

julia&gt; 3 ⊕ 2
5

julia&gt; 3.0 ⊕ 2
ERROR: MethodError: no method matching ⊕(::Float64, ::Int64)
Closest candidates are:
  ⊕(::A, ::A) where A

julia&gt; &quot;&quot; ⊕ &quot;&quot;
ERROR: Not implemented trait Monoid for (String).

julia&gt; 3.0 ⊕ 2.0
5.0

julia&gt; mempty(Int)
0

julia&gt; mempty(Float32)
0.0f0

julia&gt; @btime 100 ⊕ 200
  0.018 ns (0 allocations: 0 bytes)
300

julia&gt; @btime 100 + 200
  0.018 ns (0 allocations: 0 bytes)
300</code></pre><h2><a class="nav-anchor" id="Zero-Cost-1" href="#Zero-Cost-1">Zero Cost</a></h2><pre><code class="language-julia-repl">julia&gt; using CanonicalTraits

julia&gt; @trait Add{L, R} begin
           (+) :: [L, R] =&gt; Any
           (+) = Base.:+
       end

julia&gt; +
+ (generic function with 1 method)

julia&gt; @implement! Add{Int, Int}

julia&gt; @code_native 1 + 2
	.text
; ┌ @ none within `+&#39; @ none:0
	leaq	(%rdi,%rsi), %rax
	retq
	nopw	%cs:(%rax,%rax)
; └

julia&gt; @code_native Base.:+(1, 2)
	.text
; ┌ @ int.jl:53 within `+&#39;
	leaq	(%rdi,%rsi), %rax
	retq
	nopw	%cs:(%rax,%rax)
; └

julia&gt; function vec_add(x::Vector{T}, y::Vector{T}) where T &lt;: Number
           n = length(x)
           n !== length(y) &amp;&amp; error(&quot;mismatch&quot;)
           s = zero(T)
           for i in 1:n
              s = Base.:+(s, @inbounds x[i] * y[i])
           end
           s
       end;

julia&gt; eval(macroexpand(Base, :(Main.@btime $vec_add([1, 2, 3], [2, 3, 4]))))
  156.788 ns (3 allocations: 336 bytes)
3-element Array{Int64,1}:
 3
 5
 7

# `+` by hand-written
julia&gt; @implement! Add{Vector{T}, Vector{T}} where T &lt;: Number begin
           @inline function (+)(x, y)
              n = length(x)
              n !== length(y) &amp;&amp; error(&quot;mismatch&quot;)
              T[xe + ye for (xe, ye) in zip(x, y)]
           end
       end

# `+` by CanonicalTraits.jl       
julia&gt; eval(macroexpand(Base, :(Main.@btime $+([1, 2, 3], [2, 3, 4]))))
  159.861 ns (3 allocations: 336 bytes)
3-element Array{Int64,1}:
 3
 5
 7

# Standard `+` operator
julia&gt; eval(macroexpand(Base, :(Main.@btime +([1, 2, 3], [2, 3, 4]))))
  161.955 ns (3 allocations: 336 bytes)
3-element Array{Int64,1}:
 3
 5
 7</code></pre><h2><a class="nav-anchor" id="Limitations-1" href="#Limitations-1">Limitations</a></h2><p>Due to the limitations of dynamic language, the type parameters occurred in trait signature should occur in the argument of each trait methods. Also, cannot define constants/singletons for traits because it&#39;s a technique for static typing.</p><p>For Haskell users: <code>MultiParamTypeClasses</code> is supported. <code>FunctionalDependencies</code> is supported as well but need an explicit inference rule, like</p><pre><code class="language-julia">@trait Dot{F, V} where {F = vect_infer_helper(V)} begin
    dot :: [V, V] =&gt; F
    gram_schmidt :: [V, Set{V}] =&gt; V
end</code></pre><p>Cannot list out all limitations here, if any problem, please open an issue or e-mail me.</p><footer><hr/></footer></article></body></html>
