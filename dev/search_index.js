var documenterSearchIndex = {"docs":
[{"location":"#CanonicalTraits.jl-1","page":"Home","title":"CanonicalTraits.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Features-1","page":"Home","title":"Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Zero-cost abstractions(via @implement!)\nMultiple-param traits\nFunctional dependencies\nImplemented via dictionay passing algorithm\nElegant notations\nFlexible Instances & Flexible Classes","category":"page"},{"location":"#Trait-Definition-1","page":"Home","title":"Trait Definition","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"@trait Addable{L, R} begin\r\n    (+) :: [L, R] => Any\r\n    (+) = Base.:+\r\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Above code gives a naive implementation of +.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(+) :: [L, R] => Any says (+) is a function that takes 2 arguments typed L and R, and return an Any.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(+) = Base.:+ says + has a default implementation Base.:+.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note, the form @trait A{B, C, D <: Number, E <: AbstractString} is supported as well.","category":"page"},{"location":"#Implementation-1","page":"Home","title":"Implementation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If all methods have a default implementation, you can do","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@implement Addable{Int, Int}","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Otherwise, if there's such a trait","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@trait Show{A} begin\r\n   show :: A => String\r\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We'll have","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> @implement Show{Int}\r\nERROR: LoadError: No default method show for Show.\r\n\r\njulia> @implement Show{Int} begin\r\n    show(x) = string(x)\r\nend\r\n\r\njulia> show(114514)\r\n\"114514\"","category":"page"},{"location":"#Functional-Dependency-1","page":"Home","title":"Functional Dependency","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is an example of defining Vector-like traits,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"function vect_eltype_infer end\r\n@trait Vect{F, V} where {F = vect_infer_helper(V)} begin\r\n    scalar_mul :: [F, V] => V\r\n    scalar_div :: [V, F] => V\r\n\r\n    vec_add    :: [V, V] => V\r\n    vec_sub    :: [V, V] => V\r\n\r\n    scalar_add :: [F, V] => V\r\n    scalar_sub :: [V, F] => V\r\n\r\n    scalar_div(vec :: V, scalar :: F) = scalar_mul(one(F)/scalar, vec)\r\n    scalar_sub(vec :: V, scalar :: F) = scalar_add(-scalar, vec)\r\n    vec_sub(vec1 :: V, vec2 :: V)     = vec_add(vec1, scalar_mul(-one(F), vec2))\r\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that, for some methods of Vect, we cannot infer out the type F with their argument types:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"vec_add    :: [V, V] => V\r\nvec_sub    :: [V, V] => V","category":"page"},{"location":"#","page":"Home","title":"Home","text":"However, for instance, we know,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"when V  is Vector{T}, V is T.\nwhen V is NTuple{5, T}, V is T\netc.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This is called functional dependency, and to work with this, we provide the capability of using this, check the head of the definition of Vect:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@trait Vect{F, V} where {F = vect_infer_helper(V)} begin","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Which means that F is decided by V with vect_infer_helper.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This is an example of making Tuple{F, F} Vector-like:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"vect_infer_helper(::Type{Tuple{F, F}}) where F<:Number = F\r\n\r\n@implement Vect{F, Tuple{F, F}} where F <: Number begin\r\n    scalar_add(num, vec) =\r\n        (vec[1] + num, vec[2] + num)\r\n    vec_add(vec1, vec2) =\r\n        (vec1[1] + vec2[1], vec1[2] + vec2[2])\r\n    scalar_mul(num, vec) =\r\n        (num * vec[1], num * vec[2])\r\nend","category":"page"},{"location":"#Flexible-Instances-and-Flexible-Classes-1","page":"Home","title":"Flexible Instances & Flexible Classes","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"@trait Add1{T <: Number} begin\r\n    add1 :: [T] => T\r\nend\r\n@trait Add1{T} >: Addn{T <: Number} begin\r\n    addn :: [Int, T] => T\r\n    addn(n, x) = let s = x; for i in 1:n; s = add1(s) end; s; end\r\nend\r\n\r\n@implement Add1{Int} begin\r\n    add1(x) = x + 1\r\nend\r\n@implement Addn{Int}\r\n@implement! Add1{T} >: Add1{Vector{T}} where T begin\r\n    add1(xs) = add1.(xs)\r\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Then we can use them this way:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> add1([1])\r\n1-element Array{Int64,1}:\r\n 2\r\n\r\njulia> add1(1)\r\n2\r\n\r\njulia> addn(5, 1)\r\n6\r\n\r\njulia> addn(5, 1.2)\r\nERROR: Not implemented trait Add1 for (Float64).\r\n\r\njulia> add1([1.2])\r\nERROR: Not implemented trait Add1 for (Float64).","category":"page"},{"location":"#Use-Case-from-An-Example:-Gram-Schmidt-Orthogonalization-1","page":"Home","title":"Use Case from An Example: Gram-Schmidt Orthogonalization","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Traits manage constraints, making the constraints reasonable and decoupling implementations.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In the late 2019, a friend of mine, Yinbo, asked me if traits can help writing orthogonalizations, because he is working for projects about JuliaDiffEq.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"After pondering for some time, I made a trait-based design for Gram-Schmidt orthogonalization.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"I tidied up the logic in this way:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Gram-Schmidt orthogonalization is defined in an inner product space.\nAn inner product space derives a trait, I call it InnerProduct.\nAn inner prduct space is a vector space, with an additional structure called an inner product, which tells that we need a vector space.\nA vector space, a.k.a linear space, given a set of scalar numbers F, it is a carrier set V occupied with following operations, and we make a trait Vect for the vector space:\nvector addition: + : V × V → V\nscalar multiplication: * : F × V → V  ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Now, we could use CanonicalTraits.jl to transform above mathematical hierarchy into elegant Julia codes:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"function scalartype_of_vectorspace end\r\n@trait Vect{F <: Number, V} where\r\n    {F = scalartype_of_vectorspace(V)} begin\r\n   vec_add    :: [V, V] => V\r\n   scalar_mul :: [F, V] => V\r\nend\r\n\r\n@trait InnerProduct{F <: Number, V} where \r\n    {F = scalartype_of_vectorspace(V)} begin\r\n    dot :: [V, V] => F\r\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Then we can implement Gram-Schmidt orthogonalization,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"function gram_schmidt!(v :: V, vs :: Vector{V})::V where V\r\n    for other in vs\r\n        coef = dot(v, other) / dot(other, other)\r\n        incr = scalar_mul(-coef, other)\r\n        v = vec_add(v, incr)\r\n    end\r\n    magnitude = sqrt(dot(v, v))\r\n    scalar_mul(1/magnitude, v)\r\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"gram_schmidt!(a, [b, c, d]) will Gram-Schmidt orthogonalize a with b, c, d.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Now, other than a clean implementation, another advantage of using traits comes out:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])\r\nERROR: MethodError: no method matching scalartype_of_vectorspace(::Type{Array{Float64,1}})","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Okay, we want to use gram_schmidt! on Vector{Float64}, but we have to implement scalartype_of_vectorspace first.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"So we just say the scalar set is the real numbers\"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> scalartype_of_vectorspace(::Type{Vector{Float64}}) = Real\r\n\r\njulia> gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])\r\nERROR: Not implemented trait InnerProduct for (Real, Array{Float64,1}).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Okay, we should implement InnerProduct{Real, Vector{Float64}}.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> @implement InnerProduct{Real, Vector{Float64}} begin\r\n           dot(a, b) = sum([ai*bi  for (ai, bi) in zip(a, b)])\r\n       end\r\n\r\njulia> gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])\r\nERROR: Not implemented trait Vect for (Float64, Array{Float64,1}).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Okay, we implement Vect{Real, Vector{Float64}}.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> @implement Vect{Real, Vector{Float64}} begin\r\n          vec_add(x, y) = Float64[xi + yi for (xi, yi) in zip(x, y)]\r\n          scalar_mul(a, x) = Float64[(a)xi for xi in x]\r\n       end\r\njulia> gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])\r\n3-element Array{Float64,1}:\r\n 0.0\r\n 0.0\r\n 1.0","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Nice.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Besides, note that CanonicalTraits.jl is zero-cost.","category":"page"},{"location":"#Use-Case:-Modeling-Algebraic-Structures-1","page":"Home","title":"Use Case: Modeling Algebraic Structures","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> @trait Monoid{A} begin\r\n                  mempty :: Type{A} => A\r\n                  # a method with two arguments\r\n                  (⊕)    :: [A, A] => A\r\n              end\r\n\r\n\r\njulia> @implement Monoid{Num} where Num <: Number begin\r\n           mempty(::Type{Num}) = zero(Num)\r\n           (a :: Num) ⊕ (b :: Num) = a + b\r\n       end\r\n\r\njulia> using BenchmarkTools\r\n\r\njulia> 3 ⊕ 2\r\n5\r\n\r\njulia> 3.0 ⊕ 2\r\nERROR: MethodError: no method matching ⊕(::Float64, ::Int64)\r\nClosest candidates are:\r\n  ⊕(::A, ::A) where A\r\n\r\njulia> \"\" ⊕ \"\"\r\nERROR: Not implemented trait Monoid for (String).\r\n\r\njulia> 3.0 ⊕ 2.0\r\n5.0\r\n\r\njulia> mempty(Int)\r\n0\r\n\r\njulia> mempty(Float32)\r\n0.0f0\r\n\r\njulia> @btime 100 ⊕ 200\r\n  0.018 ns (0 allocations: 0 bytes)\r\n300\r\n\r\njulia> @btime 100 + 200\r\n  0.018 ns (0 allocations: 0 bytes)\r\n300","category":"page"},{"location":"#Zero-Cost-1","page":"Home","title":"Zero Cost","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> using CanonicalTraits\r\n\r\njulia> @trait Add{L, R} begin\r\n           (+) :: [L, R] => Any\r\n           (+) = Base.:+\r\n       end\r\n\r\njulia> +\r\n+ (generic function with 1 method)\r\n\r\njulia> @implement! Add{Int, Int}\r\n\r\njulia> @code_native 1 + 2\r\n\t.text\r\n; ┌ @ none within `+' @ none:0\r\n\tleaq\t(%rdi,%rsi), %rax\r\n\tretq\r\n\tnopw\t%cs:(%rax,%rax)\r\n; └\r\n\r\njulia> @code_native Base.:+(1, 2)\r\n\t.text\r\n; ┌ @ int.jl:53 within `+'\r\n\tleaq\t(%rdi,%rsi), %rax\r\n\tretq\r\n\tnopw\t%cs:(%rax,%rax)\r\n; └\r\n\r\njulia> function vec_add(x::Vector{T}, y::Vector{T}) where T <: Number\r\n           n = length(x)\r\n           n !== length(y) && error(\"mismatch\")\r\n           s = zero(T)\r\n           for i in 1:n\r\n              s = Base.:+(s, @inbounds x[i] * y[i])\r\n           end\r\n           s\r\n       end;\r\n\r\njulia> eval(macroexpand(Base, :(Main.@btime $vec_add([1, 2, 3], [2, 3, 4]))))\r\n  156.788 ns (3 allocations: 336 bytes)\r\n3-element Array{Int64,1}:\r\n 3\r\n 5\r\n 7\r\n\r\n# `+` by hand-written\r\njulia> @implement! Add{Vector{T}, Vector{T}} where T <: Number begin\r\n           @inline function (+)(x, y)\r\n              n = length(x)\r\n              n !== length(y) && error(\"mismatch\")\r\n              T[xe + ye for (xe, ye) in zip(x, y)]\r\n           end\r\n       end\r\n\r\n# `+` by CanonicalTraits.jl       \r\njulia> eval(macroexpand(Base, :(Main.@btime $+([1, 2, 3], [2, 3, 4]))))\r\n  159.861 ns (3 allocations: 336 bytes)\r\n3-element Array{Int64,1}:\r\n 3\r\n 5\r\n 7\r\n\r\n# Standard `+` operator\r\njulia> eval(macroexpand(Base, :(Main.@btime +([1, 2, 3], [2, 3, 4]))))\r\n  161.955 ns (3 allocations: 336 bytes)\r\n3-element Array{Int64,1}:\r\n 3\r\n 5\r\n 7","category":"page"},{"location":"#Limitations-1","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Due to the limitations of dynamic language, the type parameters occurred in trait signature should occur in the argument of each trait methods. Also, cannot define constants/singletons for traits because it's a technique for static typing.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For Haskell users: MultiParamTypeClasses is supported. FunctionalDependencies is supported as well but need an explicit inference rule, like","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@trait Dot{F, V} where {F = vect_infer_helper(V)} begin\r\n    dot :: [V, V] => F\r\n    gram_schmidt :: [V, Set{V}] => V\r\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Cannot list out all limitations here, if any problem, please open an issue or e-mail me.","category":"page"}]
}
