var documenterSearchIndex = {"docs":
[{"location":"#CanonicalTraits.jl-1","page":"Home","title":"CanonicalTraits.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Trait-Definition-1","page":"Home","title":"Trait Definition","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"@trait Addable{L, R} begin\r\n    (+) :: [L, R] => Any\r\n    (+) = Base.:+\r\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Above code gives a naive implementation of +.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(+) :: [L, R] => Any says (+) is a function that takes 2 arguments typed L and R, and return an Any.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(+) = Base.:+ says + has a default implementation Base.:+.","category":"page"},{"location":"#Implementation-1","page":"Home","title":"Implementation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If all methods have a default implementation, you can do","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@implement Addable{Int, Int}","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Otherwise, if there's such a trait","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@trait Show{A} begin\r\n   show :: A => String\r\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We'll have","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> @implement Show{Int}\r\nERROR: LoadError: No default method show for Show.\r\n\r\njulia> @implement Show{Int} begin\r\n    show(x) = string(x)\r\nend\r\n\r\njulia> show(114514)\r\n\"114514\"","category":"page"},{"location":"#Functional-Dependency-1","page":"Home","title":"Functional Dependency","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is an example of defining Vector-like traits,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"function vect_eltype_infer end\r\n@trait Vect{F, V} where {F = vect_infer_helper(V)} begin\r\n    scalar_mul :: [F, V] => V\r\n    scalar_div :: [V, F] => V\r\n\r\n    vec_add    :: [V, V] => V\r\n    vec_sub    :: [V, V] => V\r\n\r\n    scalar_add :: [F, V] => V\r\n    scalar_sub :: [V, F] => V\r\n\r\n    scalar_div(vec :: V, scalar :: F) = scalar_mul(one(F)/scalar, vec)\r\n    scalar_sub(vec :: V, scalar :: F) = scalar_add(-scalar, vec)\r\n    vec_sub(vec1 :: V, vec2 :: V)     = vec_add(vec1, scalar_mul(-one(F), vec2))\r\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that, for some methods of Vect, we cannot infer out the type F with their argument types:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"vec_add    :: [V, V] => V\r\nvec_sub    :: [V, V] => V","category":"page"},{"location":"#","page":"Home","title":"Home","text":"However, for instance, we know,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"when V  is Vector{T}, V is T.\nwhen V is NTuple{5, T}, V is T\netc.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This is called functional dependency, and to work with this, we provide the capability of using this, check the head of the definition of Vect:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@trait Vect{F, V} where {F = vect_infer_helper(V)} begin","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Which means that F is decided by V with vect_infer_helper.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This is an example of making Tuple{F, F} Vector-like:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"vect_infer_helper(::Type{Tuple{F, F}}) where F<:Number = F\r\n\r\n@implement Vect{F, Tuple{F, F}} where F <: Number begin\r\n    scalar_add(num, vec) =\r\n        (vec[1] + num, vec[2] + num)\r\n    vec_add(vec1, vec2) =\r\n        (vec1[1] + vec2[1], vec1[2] + vec2[2])\r\n    scalar_mul(num, vec) =\r\n        (num * vec[1], num * vec[2])\r\nend","category":"page"},{"location":"#Use-Case-from-An-Example:-Gram-Schmidt-Orthogonalization-1","page":"Home","title":"Use Case from An Example: Gram-Schmidt Orthogonalization","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Traits manage constraints, making the constraints reasonable and decoupling implementations.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In the late 2019, a friend of mine, Yinbo, asked me if traits can help writing orthogonalizations, because he is working for projects about JuliaDiffEq.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"After pondering for some time, I made a trait-based design for Gram-Schmidt orthogonalization.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"I tidied up the logic in this way:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Gram-Schmidt orthogonalization is defined in an inner product space.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"An inner product space derives a trait, I call it InnerProduct.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"An inner prduct space is a vector space, with an additional structure called an inner product, which tells that we need a vector space.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A vector space, a.k.a linear space, given a set of scalar numbers F, it is a carrier set V occupied with these operations:\nvector addition: + : V × V → V\nscalar multiplication: * : F × V → V","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Just make a trait `Vect` for the vector space.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Then we can use CanonicalTraits.jl to transform above mathematical hierarchy into elegant Julia codes:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"function scalartype_of_vectorspace end\r\n@trait Vect{F <: Number, V} where\r\n    {F = scalartype_of_vectorspace(V)} begin\r\n   vec_add    :: [V, V] => V\r\n   scalar_mul :: [F, V] => V\r\nend\r\n\r\n@trait InnerProduct{F <: Number, V} where \r\n    {F = scalartype_of_vectorspace(V)} begin\r\n    dot :: [V, V] => F\r\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Then we can implement Gram-Schmidt orthogonalization,","category":"page"},{"location":"#","page":"Home","title":"Home","text":"function gram_schmidt!(v :: V, vs :: Vector{V})::V where V\r\n    for other in vs\r\n        coef = dot(v, other) / dot(other, other)\r\n        incr = scalar_mul(-coef, other)\r\n        v = vec_add(v, incr)\r\n    end\r\n    magnitude = sqrt(dot(v, v))\r\n    scalar_mul(1/magnitude, v)\r\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"gram_schmidt!(a, [b, c, d]) will Gram-Schmidt orthogonalize a with b, c, d.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Now, other than a clean implementation, another advantage of using traits comes out:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])\r\nERROR: MethodError: no method matching scalartype_of_vectorspace(::Type{Array{Float64,1}})","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Okay, we want to use gram_schmidt! on Vector{Float64}, but we have to implement scalartype_of_vectorspace first.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"So we just say the scalar set is the real numbers\"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> scalartype_of_vectorspace(::Type{Vector{Float64}}) = Real\r\n\r\njulia> gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])\r\nERROR: Not implemented trait InnerProduct for (Real, Array{Float64,1}).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Okay, we should implement InnerProduct{Real, Vector{Float64}}.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> @implement InnerProduct{Real, Vector{Float64}} begin\r\n           dot(a, b) = sum([ai*bi  for (ai, bi) in zip(a, b)])\r\n       end\r\n\r\njulia> gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])\r\nERROR: Not implemented trait Vect for (Float64, Array{Float64,1}).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Okay, we implement Vect{Real, Vector{Float64}}.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> @implement Vect{Real, Vector{Float64}} begin\r\n          vec_add(x, y) = Float64[xi + yi for (xi, yi) in zip(x, y)]\r\n          scalar_mul(a, x) = Float64[(a)xi for xi in x]\r\n       end\r\njulia> gram_schmidt!([1.0, 1, 1], [[1.0, 0, 0], [0, 1.0, 0]])\r\n3-element Array{Float64,1}:\r\n 0.0\r\n 0.0\r\n 1.0","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Nice.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Besides, note that CanonicalTraits.jl is zero-cost.","category":"page"}]
}
